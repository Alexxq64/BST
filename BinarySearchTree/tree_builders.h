#ifndef TREE_BUILDERS_H
#define TREE_BUILDERS_H

#include "tree_node.h"
#include <vector>

/**
 * @file tree_builders.h
 * @brief Построение различных типов деревьев поиска
 *
 * Этот файл содержит функции для построения Идеально Сбалансированного Дерева Поиска (ИСДП)
 * и Случайного Дерева Поиска (СДП) из массивов данных.
 */

class TreeBuilders {
public:
    /**
     * @brief Построение Идеально Сбалансированного Дерева Поиска (ИСДП)
     * @param sortedData Отсортированный массив уникальных чисел
     * @return Указатель на корень построенного ИСДП
     *
     * @note Для построения ИСДП входные данные должны быть отсортированы.
     *       Алгоритм рекурсивно выбирает средний элемент в качестве корня,
     *       что гарантирует сбалансированность дерева.
     */
    static TreeNode* buildPerfectlyBalancedTree(const std::vector<int>& sortedData);

    /**
     * @brief Построение Случайного Дерева Поиска (СДП)
     * @param data Массив чисел (может быть неотсортированным)
     * @return Указатель на корень построенного СДП
     *
     * @note Элементы вставляются в дерево в том порядке, в котором они находятся в массиве.
     *       Структура дерева зависит от порядка элементов.
     */
    static TreeNode* buildRandomSearchTree(const std::vector<int>& data);

    /**
     * @brief Проверка, является ли дерево деревом поиска
     * @param root Указатель на корень дерева
     * @return true если дерево является деревом поиска, false в противном случае
     *
     * @note Дерево поиска должно удовлетворять условию: для каждого узла все элементы
     *       в левом поддереве меньше, а в правом - больше значения узла.
     */
    static bool isBinarySearchTree(TreeNode* root);

    /**
     * @brief Освобождение памяти, занятой деревом
     * @param root Указатель на корень дерева
     *
     * @important Всегда вызывайте эту функцию для удаления дерева после использования,
     *            чтобы избежать утечек памяти.
     */
    static void deleteTree(TreeNode* root);

private:
    /**
     * @brief Вспомогательная рекурсивная функция для построения ИСДП
     * @param sortedData Отсортированный массив данных
     * @param start Начальный индекс подмассива
     * @param end Конечный индекс подмассива
     * @return Указатель на корень поддерева
     *
     * Рекурсивно строит ИСДП, выбирая средний элемент в качестве корня
     * и рекурсивно строя левое и правое поддеревья.
     */
    static TreeNode* buildBalancedTreeRecursive(const std::vector<int>& sortedData, int start, int end);

    /**
     * @brief Вспомогательная функция для вставки узла в СДП
     * @param root Указатель на корень дерева (может изменяться)
     * @param key Ключ для вставки
     *
     * Вставляет новый узел в дерево поиска согласно правилам BST.
     */
    static void insertNode(TreeNode*& root, int key);

    /**
     * @brief Вспомогательная рекурсивная функция проверки BST
     * @param node Текущий узел
     * @param minValue Минимально допустимое значение в поддереве
     * @param maxValue Максимально допустимое значение в поддереве
     * @return true если поддерево является BST
     *
     * Рекурсивно проверяет выполнение условий BST для каждого узла.
     */
    static bool isBSTRecursive(TreeNode* node, int minValue, int maxValue);
};

#endif // TREE_BUILDERS_H